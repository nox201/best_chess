<!DOCTYPE html>
<head>

	<title>Bishops Castle</title>
	<script src="Piece.js"></script>
	<script src="Pawn.js"></script>
	<script src="Castle.js"></script>
	<script src="Knight.js"></script>
	<script src="Bishop.js"></script>
	<script src="Queen.js"></script>
	<script src="King.js"></script>
	
	<style>
	.background {
		--s: 61px; /* control the size*/
		--c1: #b2b2b2;
		--c2: #ffffff;
		--c3: #d9d9d9;
	  
		--_g: var(--c3) 0 120deg,#0000 0;
		background:
			conic-gradient(from -60deg at 50% calc(100%/3),var(--_g)),
			conic-gradient(from 120deg at 50% calc(200%/3),var(--_g)),
			conic-gradient(from  60deg at calc(200%/3),var(--c3) 60deg,var(--c2) 0 120deg,#0000 0),
			conic-gradient(from 180deg at calc(100%/3),var(--c1) 60deg,var(--_g)),
			linear-gradient(90deg,var(--c1) calc(100%/6),var(--c2) 0 50%, var(--c1) 0 calc(500%/6),var(--c2) 0);
		background-size: calc(1.732*var(--s)) var(--s);
	}
	
	#board {
		border: 1px solid black;
	}
	#boardContainer {
		height: 0px;
		width: 40%;
		padding-bottom: 40%;
		display: inline-block;
		<!-- background-color: red; -->
	}
	
	.main {
		text-align: center;
	}
	
	.dataContainer {
		display: inline-block;
		background-color: white;
		vertical-align: top;
		text-align: left;
		padding: 20px;
		border-radius: 5px;
	}
	
	.turnDisplay {
		margin-top: 200px;
	}
	
	.inverted {
		background-color: black;
		color: white;
	}
	
	</style>
</head>
<body class="background">

	<div class="main">
	
		<button id="testMove">Make Move</button>

		<div class="dataContainer turnDisplay">
			<span id="whiteTurnDisplay">White's Move</span>
		</div>
		
		<div class="dataContainer">
			<span id="whiteTakenPool">White has taken: </span>
			<table id="whiteTakenTable">
			</table>
		</div>
		
		<div id="boardContainer">
			<canvas id="board" width="100%" height="100%"></canvas>
		</div>
		
		<div class="dataContainer inverted">
			<span id="blackTakenPool">Black has taken: </span>
			<table id="blackTakenTable">
			</table>
		</div>
		
		<div class="dataContainer turnDisplay inverted">
			<span id="blackTurnDisplay">Black's Move</span>
		</div>
		
	</div>

</body>

<script>
	
	//INITALIZE VARIABLES
	var boardContainer = document.getElementById('boardContainer');
	var canvas = document.getElementById('board');
	var plane = canvas.getContext('2d');
	var selectedRow;
	var selectedColumn;
	var currentTurn;
	var defendingCheck = false;
	
	//ON LOAD
	window.addEventListener('load', (event) => {
	
		//SET CANVAS SIZE TO PARENT DIV - ALLOWS DYNAMIC RESIZING OF THE CANVAS, WHILE FORCING IT TO BE SQUARE
		canvas.width = parseInt(getComputedStyle(boardContainer).getPropertyValue('width'), 10);
		canvas.height = canvas.width;
		//SET SQUARE DIMENSIONS
		var squareSize = Math.floor(canvas.width / 8);
		
		//BIND HIGHEST LEVEL EVENT LISTENER
		canvas.addEventListener('click', handleCanvasClicked);
		
		//SET WHITE TO GO FIRST
		//I call swapTurn when starting the game, so this is set to black so that white goes first
		currentTurn = 'black';
		
		//HANDLE CLICK
		function handleCanvasClicked(event)
		{
			//DETERMINE WHICH SQUARE HAS BEEN CLICKED
			let row = Math.floor(event.offsetX / squareSize);
			let column = Math.floor(event.offsetY / squareSize);
			//PASS EVENT TO OBJECT
			squares[row][column].handleClick(event);
		}

		//SQUARE CLASS
		//Represents one of the 64 coloured squares on the chessboard
		class Square {
			constructor(plane, row, column, colour, contains){
				this.plane = plane;
				this.row = row;
				this.column = column;
				this.colour = colour;
				this.contains = contains;
				//utility variables
				this.centreX = squareSize * this.row + (squareSize / 2);
				this.centreY = squareSize * this.column + (squareSize / 2);
			};
			plane;
			row;
			column;
			colour;
			contains;
			centreX;
			centreY;
			selected = false;
			highlighted = false;
			checked = false;
			checkMated = false;
			
			//ADDS A PIECE TO THE SQUARE
			addPiece = function(piece){
				this.contains = piece;
			}
			//SETS THE CONTAINED PIECES SQUARE DATA, THEN RETURNS IT
			getPiece = function(){
				if(this.contains != null){
					this.contains.setRow(this.row);
					this.contains.setColumn(this.column);
					return this.contains;
				}else{
					return null;
				}
			}
			
			//DRAWS THE SQUARE, INCLUDING ANY PIECE IN THE SQUARE
			draw = function(){
			
				//CHECK IF PIECE SELECTED
				if(this.selected){
					plane.fillStyle = 'green';
				}else if(this.highlighted){
					plane.fillStyle = 'lightgreen';
				}else if(this.checked){
				console.log('should be checked');
					plane.fillStyle = 'red';
				}else if(this.checkMated){
					plane.fillStyle = 'purple';
				}else{
					plane.fillStyle = this.colour;
				}
				plane.fillRect(squareSize * this.row, squareSize * this.column, squareSize, squareSize);
				
				if(this.getPiece() != null){
					//DRAW PIECE
					this.getPiece().draw(this.row, this.column, squareSize);
				}
			};
			
			//SQUARE-SPECIFIC CLICK HANDLER
			handleClick(event){
			
				//LOG
				//console.log('square ' + this.row + ', ' + this.column + ' clicked');
				
				//CHECK IF HIGHLIGHTED - PIECE HAS ALREADY BEEN SELECTED, THIS CLICK WILL BE A VALID MOVE
				if(this.highlighted == true){
				
					//CHECK FOR OPPONENTS PIECE
					if(this.getPiece() != null){
					//TAKE PIECE
						updateTakenPool(this.getPiece());
					}
					//MOVE PIECE
					this.addPiece(squares[selectedRow][selectedColumn].getPiece());
					//REMOVE PIECE FROM OLD SQUARE
					squares[selectedRow][selectedColumn].contains = null;
					
					//DESELECT EVERYTHING
					deselectEverything();
					
					//CHECK FOR ATTACKING CHECK
					//this isnt the best way to do it, its useless for any of the other check related stuff, like preventing a player moving into check, or playing a move that doesnt get them out of CHECK
					//i should have something that checks the boardstate for a check or checkmate
					let piecesValidMoves = this.getPiece().getValidMoves(getBoardState());
					for(let i = 0; i < piecesValidMoves.length; i++){
						if(squares[piecesValidMoves[i].row][piecesValidMoves[i].column].getPiece() != null){
							if(squares[piecesValidMoves[i].row][piecesValidMoves[i].column].getPiece().getName() == 'King'){
								squares[piecesValidMoves[i].row][piecesValidMoves[i].column].checked = true;
								defendingCheck = true;
							}
						}
					}
					
					//SWAP TURN
					swapTurn();
					
				//SQUARE NOT HIGHLIGHTED - CHECK IF SQUARE HAS A PIECE CONTAINED
				}else if(this.getPiece() != null){
				
					//DIFFERNENT PIECE SELECTED, DESELECT EVERYTHING
					deselectEverything();
					//CHECK IF ITS THE RIGHT PIECES TURN
					if(this.getPiece().colour == currentTurn){
						//SET SELECTED
						this.selected = true;
						//SET UTILITY VARIABLE
						//do i need these?
						selectedRow = this.row;
						selectedColumn = this.column;
						
						//SET PIECES VALID MOVES TO HIGHLIGHTED
						let validMoves = this.getPiece().getValidMoves(getBoardState());
						for(i = 0; i < validMoves.length; i++){
							//CHECK FOR ERROR
							if(typeof(squares[validMoves[i].row][validMoves[i].column]) == 'undefined'){
								alert('Undefined: attempting to access row: ' + validMoves[i].row + ', column: ' + validMoves[i].column);
							}else{
								//HIGHLIGHT VALID MOVE SQUARES
								squares[validMoves[i].row][validMoves[i].column].highlighted = true;
							}
						}
					}
					
				}else{
					//EMPTY SQUARE CLICKED - DESELECT EVERYTHING
					deselectEverything();
				}
				
				//REDRAW BOARD
				drawBoard();
			}
		}
		
		//=================
		//UTILITY FUNCTIONS
		//=================
		
		function deselectEverything()
		{
			//ITERATE SQUARES
			squares.forEach((row) => {
				row.forEach((column) => {
					column.selected = false;
					column.highlighted = false;
				})
			});
		}
		
		function getBoardState()
		{
			let state = [];
			//ITERATE SQUARES
			squares.forEach((row) => {
				row.forEach((column) => {
					if(column.getPiece() != null){
						let currentPiece = column.getPiece();
						state.push({'row': currentPiece.row, 'column': currentPiece.column, 'colour': currentPiece.colour, 'piece': currentPiece});
					}
				})
			});
			return state;
		}
		
		function updateTakenPool(piece)
		{
			if(piece.colour == 'black'){
				document.getElementById('whiteTakenTable').insertRow(0).insertCell(0).innerHTML = piece.getName();
			}else{
				document.getElementById('blackTakenTable').insertRow(0).insertCell(0).innerHTML = piece.getName();
			}
		}
		
		function swapTurn()
		{
			if(currentTurn == 'white'){
				currentTurn = 'black';
				document.getElementById('whiteTurnDisplay').style.color = 'white';
				document.getElementById('blackTurnDisplay').style.color = 'white';
			}else{
				currentTurn = 'white';
				document.getElementById('whiteTurnDisplay').style.color = 'black';
				document.getElementById('blackTurnDisplay').style.color = 'black';
			}
		}
		
		function makeMove()
		{
			//INIT SCOPED VARIABLES
			let boardState = getBoardState();
			let player = currentTurn;
			let allValidMoves = [];
			let selectedSquare = null;
			let selectedMove = null;
			
			//ITERATE THE BOARD STATE
			boardState.forEach((piece) => {
				//ONLY COMPUTE THE MOVE FOR THE CURRENT PLAYER
				if(piece.colour == player){
					//ONLY STORE VALID MOVES THAT CAN BE MADE (getValidMoves can return an empty array)
					if(piece.piece.getValidMoves(boardState).length > 0){
						allValidMoves.push({'piece': piece, 'moves': piece.piece.getValidMoves(boardState)});
					}
				}
			});
			
			//console.log(allValidMoves);
			//for(let i = 0; i < allValidMoves.length; i++){
				//for(let j = 0; j < allValidMoves[i].moves.length; j++){
					//console.log(allValidMoves[i].moves);
					//squares[allValidMoves[i].moves[j].row][allValidMoves[i].moves[j].column].highlighted = true;
					
					//squares[allValidMoves[i].moves[j].row][allValidMoves[i].moves[j].column].addPiece(allValidMoves[i].piece);
					//squares[allValidMoves[i].piece.row][allValidMoves[i].piece.column].contains = null;
				//}
			//}
			
			//LOG ALL VALID MOVES
			//console.log('allValidMoves[0].moves[0].row: ' + allValidMoves[0].moves[0].row + ', allValidMoves[0].moves[0].column: ' + allValidMoves[0].moves[0].column + ', piece: ' + allValidMoves[0].piece);
			
			//---------
			//RANDOM AI
			//---------
			
			//PICK RANDOM PIECE TO MOVE
			randomPieceIndex = Math.floor(Math.random() * allValidMoves.length);
			//PICK RANDOM MOVE FOR THAT RANDOM PIECE
			randomMoveIndex = Math.floor(Math.random() * allValidMoves[randomPieceIndex].moves.length);
			
			//SET UTILITY VARIABLES - KEEPS THE LINES SHORTER :D
			selectedSquare = squares[allValidMoves[randomPieceIndex].piece.row][allValidMoves[randomPieceIndex].piece.column];
			selectedMove = allValidMoves[randomPieceIndex].moves[randomMoveIndex];
			
			//LOG AI MOVE
			console.log('AI move: ' + selectedSquare.getPiece().colour + ' ' + selectedSquare.getPiece().getName() + ' at row ' + selectedSquare.getPiece().row + ', column ' + selectedSquare.getPiece().column + ' moves to row ' + selectedMove.row + ', column ' + selectedMove.column);
			
			//ADD PIECE TO SQUARES BY GETTING PIECE FROM THE SQUARES - DONT PASS THE PIECE OBJECT AROUND
			squares[selectedMove.row][selectedMove.column].addPiece(selectedSquare.getPiece());
			//REMOVE PIECE FROM OLD LOCATION
			selectedSquare.contains = null;
			
			//UPDATE TAKEN POOL?
			//this function takes a piece - haven't got logic for working out if a piece was taken yet
			//SWAP PLAYER
			swapTurn();
			//REDRAW
			drawBoard();
		}
		//BIND AI MOVE TO BUTTON FOR TESTING
		document.getElementById('testMove').addEventListener('click', makeMove);
		
		
		
		//=================
		//BOARD FUNCTIONS
		//=================

		//POPULATE BOARD WITH 8X8 SQUARES
		var squares = [];
		var squareColour = 'grey';
		for(i = 0; i < 8; i++){
			squares[i] = [];
			for(j = 0; j < 8; j++){
				//DONT ALTERNATE COLOUR ON THE FIRST SQUARE OF EACH ROW
				if(j != 0){
					if(squareColour == 'white'){
						squareColour = 'grey';
					}else{
						squareColour = 'white';
					}
				}
				//CREATE SQUARE
				squares[i].push(new Square(plane, i, j, squareColour, null));
			}
		}
		
		function populateBoard()
		{
			//ADD PAWNS
			for(i = 0; i < 8; i++){
				squares[i][1].addPiece(new Pawn(plane, 'black'));
				squares[i][6].addPiece(new Pawn(plane, 'white'));
			}
			//ADD WHITE
			squares[0][7].addPiece(new Castle(plane, 'white'));
			squares[1][7].addPiece(new Knight(plane, 'white'));
			squares[2][7].addPiece(new Bishop(plane, 'white'));
			squares[3][7].addPiece(new King(plane, 'white'));
			squares[4][7].addPiece(new Queen(plane, 'white'));
			squares[5][7].addPiece(new Bishop(plane, 'white'));
			squares[6][7].addPiece(new Knight(plane, 'white'));
			squares[7][7].addPiece(new Castle(plane, 'white'));
			//ADD BLACK
			squares[0][0].addPiece(new Castle(plane, 'black'));
			squares[1][0].addPiece(new Knight(plane, 'black'));
			squares[2][0].addPiece(new Bishop(plane, 'black'));
			squares[3][0].addPiece(new Queen(plane, 'black'));
			squares[4][0].addPiece(new King(plane, 'black'));
			squares[5][0].addPiece(new Bishop(plane, 'black'));
			squares[6][0].addPiece(new Knight(plane, 'black'));
			squares[7][0].addPiece(new Castle(plane, 'black'));
			
		}
		
		function drawBoard()
		{
			//ITERATE SQUARES
			squares.forEach((row) => {
				row.forEach((column) => {
					//DRAW SQUARE
					column.draw();
				})
			});
		}

		//draw board first time for testing
		populateBoard();
		drawBoard();
		swapTurn();

	
	//close onload function
	}
);


</script>